<?xml version="1.0" encoding="UTF-8"?>
<itop_design xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             version="1.0">
  <module_parameters>
    <parameters  id="combodo-anonymizer" _delta="define">
      <caselog_content type="array">
        <field id="0">friendlyname</field>
        <field id="1">email</field>
        <field id="2">name</field>
      </caselog_content>
      <onmention>trigger-only</onmention>
      <notification_content type="array">
        <field id="0">friendlyname</field>
        <field id="1">email</field>
        <field id="2">name</field>
      </notification_content>
    </parameters>
  </module_parameters>
  <constants>
  </constants>
  <classes>
    <class id="RessourceAnonymization" _delta="define">
      <parent>AbstractResource</parent>
      <properties>
        <comment>/* Anonymization menu access control. */</comment>
        <abstract>true</abstract>
        <category>grant_by_profile</category>
      </properties>
      <presentation/>
      <methods/>
    </class>
    <class id="BatchAnonymization" _delta="define">
      <parent>DBObject</parent>
      <properties>
        <category></category>
        <abstract>false</abstract>
        <db_table>priv_batch_anonymization</db_table>
        <naming>
          <format>%1$s %2$s</format>
          <attributes>
            <attribute id="class_to_anonymize"/>
            <attribute id="id_to_anonymize"/>
          </attributes>
        </naming>
      </properties>
      <fields>
        <field id="class_to_anonymize" xsi:type="AttributeString">
          <sql>class_to_anonymize</sql>
          <default_value></default_value>
          <is_null_allowed>false</is_null_allowed>
          <tracking_level>none</tracking_level>
        </field>
        <field id="id_to_anonymize" xsi:type="AttributeInteger">
          <sql>id_to_anonymize</sql>
          <default_value></default_value>
          <is_null_allowed>false</is_null_allowed>
          <tracking_level>none</tracking_level>
        </field>
        <field id="id_user_to_anonymize" xsi:type="AttributeInteger">
          <sql>id_user_to_anonymize</sql>
          <default_value></default_value>
          <is_null_allowed>true</is_null_allowed>
          <tracking_level>none</tracking_level>
        </field>
        <field id="email_to_anonymize" xsi:type="AttributeString">
          <sql>email_to_anonymize</sql>
          <default_value></default_value>
          <is_null_allowed>true</is_null_allowed>
          <tracking_level>none</tracking_level>
        </field>
        <field id="friendlyname_to_anonymize" xsi:type="AttributeString">
          <sql>friendlyname_to_anonymize</sql>
          <default_value></default_value>
          <is_null_allowed>false</is_null_allowed>
          <tracking_level>none</tracking_level>
        </field>
        <field id="anonymized_friendlyname" xsi:type="AttributeString">
          <sql>anonymized_friendlyname</sql>
          <default_value></default_value>
          <is_null_allowed>false</is_null_allowed>
          <tracking_level>none</tracking_level>
        </field>
        <field id="name_to_anonymize" xsi:type="AttributeString">
          <sql>name_to_anonymize</sql>
          <default_value></default_value>
          <is_null_allowed>false</is_null_allowed>
          <tracking_level>none</tracking_level>
        </field>
        <field id="function" xsi:type="AttributeText">
          <sql>function</sql>
          <default_value></default_value>
          <is_null_allowed>false</is_null_allowed>
          <tracking_level>none</tracking_level>
        </field>
      </fields>
      <methods>
        <method id="executeStep" _delta="define">
          <static>false</static>
          <access>public</access>
          <type>Overload-DBObject</type>
          <code><![CDATA[
        public function executeStep($iTimeLimit){
           switch ($this->Get('function')) {
              case 'PurgeHistoryByBatch':
                return $this->PurgeHistoryByBatch( $iTimeLimit);
              break;
              case 'CleanupCaseLogsByBatch':
                return $this->CleanupCaseLogsByBatch( $iTimeLimit);
              break;
              case 'CleanupOnMentionByBatch':
                return $this->CleanupOnMentionByBatch( $iTimeLimit);
              break;
              case 'CleanupEmailByBatch':
                return $this->CleanupEmailByBatch( $iTimeLimit);
              break;
              default:
                echo '!!!! ERROR FUNCTION '.$this->Get('function').' NOT FOUND. Please check the code !';
                return true;
            }
        }
        ]]></code>
        </method>
        <method id="executeQueryByLot" _delta="define">
          <static>true</static>
          <access>protected</access>
          <type>Overload-DBObject</type>
          <code><![CDATA[
        protected static function executeQueryByLot($sSqlSearch, $sSqlUpdate, $iTimeLimit){
            $iMaxBufferSize =   MetaModel::GetConfig()->GetModuleSetting('combodo-anonymizer', 'max_buffer_size', 1000);
            $aObjects = [] ;
	          $bExecuteQuery = true;
            while ($bExecuteQuery) {
                    $oResult = CMDBSource::Query($sSqlSearch." LIMIT " . $iMaxBufferSize);
                    //echo("\n Search anonymization: ".$sSqlSearch);
                    $aObjects = [] ;
                    if ($oResult->num_rows>0) {
                      while ($oRaw = $oResult->fetch_assoc()) {
                        $aObjects[] = $oRaw['id'];
                      }
                      $sSQL =$sSqlUpdate."WHERE id IN (".implode(', ', $aObjects).");";
                    //  echo("\n AnonymizationUpdate: ".$sSQL);
                      CMDBSource::Query($sSQL);
                   }
                   if (count($aObjects)<$iMaxBufferSize || (time() >= $iTimeLimit)) {
                      $bExecuteQuery=false;
                  }
            }
            return (count($aObjects)<$iMaxBufferSize);
        }
        ]]></code>
        </method>
        <method id="PurgeHistoryByBatch" _delta="define">
          <static>false</static>
          <access>protected</access>
          <type>Overload-DBObject</type>
          <code><![CDATA[
        protected function PurgeHistoryByBatch( $iTimeLimit)
        {
          $oPerson =  MetaModel::GetObject('Person',$this->Get('id_to_anonymize'), true);
          // Cleanup all non mandatory values //end of job
          foreach(MetaModel::ListAttributeDefs('Person') as $sAttCode => $oAttDef)
          {
            if (!$oAttDef->IsWritable()) continue;

            if ($oAttDef instanceof AttributeLinkedSetIndirect)
            {
              $oValue = DBObjectSet::FromScratch($oAttDef->GetLinkedClass());
              $oPerson->Set($sAttCode, $oValue);
            }
          }
         $oPerson->DBWrite();

	        $oFilter = new DBObjectSearch('CMDBChangeOp');
        	$oFilter->AddCondition('objclass', 'User');
        	$oFilter->AddCondition('objkey', $this->Get('id_user_to_anonymize'), '=');
        	MetaModel::PurgeData($oFilter);

        	// Delete any existing change tracking about the current object
        	$oFilter = new DBObjectSearch('CMDBChangeOp');
        	$oFilter->AddCondition('objclass', $this->Get('class_to_anonymize'), '=');
        	$oFilter->AddCondition('objkey', $this->Get('id_to_anonymize'), '=');
        	MetaModel::PurgeData($oFilter);

        	$oMyChangeOp = MetaModel::NewObject("CMDBChangeOpPlugin");
        	$oMyChangeOp->Set("objclass", $this->Get('class_to_anonymize'));
        	$oMyChangeOp->Set("objkey", $this->Get('id_to_anonymize'));
        	$oMyChangeOp->Set("description", 'Anonymization');
        	$iId = $oMyChangeOp->DBInsertNoReload();

           // Now remove the name of the contact from all the changes she/he made
           $sChangeTable = MetaModel::DBGetTable('CMDBChange');

           if (version_compare(ITOP_DESIGN_LATEST_VERSION , '3.0') < 0  || is_null($this->Get('id_user_to_anonymize')) ) {
              $sSqlSearch = "SELECT id from `$sChangeTable` WHERE userinfo=".CMDBSource::Quote($this->Get('friendlyname_to_anonymize'));
              $sSqlUpdate = "UPDATE `$sChangeTable` SET userinfo=".CMDBSource::Quote($this->Get('anonymized_friendlyname'));
             $bFinish = $this->executeQueryByLot($sSqlSearch,$sSqlUpdate, $iTimeLimit);

	           if ( $bFinish ) {
		           $sSqlSearch = "SELECT id from `$sChangeTable` WHERE userinfo=".CMDBSource::Quote($this->Get('friendlyname_to_anonymize').' (CSV)');
		           $sSqlUpdate = "UPDATE `$sChangeTable` SET userinfo=".CMDBSource::Quote($this->Get('anonymized_friendlyname').' (CSV)');
		           $bFinish = $this->executeQueryByLot($sSqlSearch, $sSqlUpdate, $iTimeLimit);
	           }
               if($bFinish) {
                  $this->DBDelete();
                 $oScopeQuery = "SELECT BatchAnonymization WHERE id_to_anonymize = :id_to_anonymize ";
                 $oSet = new DBObjectSet(DBSearch::FromOQL($oScopeQuery, ['id_to_anonymize'=>$this->Get('id_to_anonymize')]));
                  if ($oSet->Count() === 0){
                      //end of anonymization mark person as anonymized
                    $oPerson = MetaModel::GetObject('Person', $this->Get('id_to_anonymize'), true,true);
                    $oPerson->Set('anonymized', true); // Mark the Person as anonymized
                    $oPerson->DBWrite();
                  }
              }
           } else  {
              $sSqlSearch = "SELECT id from `$sChangeTable` WHERE user_id=". $this->Get('id_user_to_anonymize');
              $sSqlUpdate = "UPDATE `$sChangeTable` SET userinfo=".CMDBSource::Quote($this->Get('anonymized_friendlyname'));
              $bFinish = $this->executeQueryByLot($sSqlSearch,$sSqlUpdate, $iTimeLimit);

	           if ( $bFinish ) {
	           	    //remove data created before 3.0
                 $sSqlSearch = "SELECT id from `$sChangeTable` WHERE userinfo=".CMDBSource::Quote($this->Get('friendlyname_to_anonymize')).' AND user_id IS NULL';
                 $sSqlUpdate = "UPDATE `$sChangeTable` SET userinfo=".CMDBSource::Quote($this->Get('anonymized_friendlyname'));
                 $bFinish = $this->executeQueryByLot($sSqlSearch, $sSqlUpdate, $iTimeLimit);
	           }
	           if ( $bFinish ) {
                 $sSqlSearch = "SELECT id from `$sChangeTable` WHERE userinfo=".CMDBSource::Quote($this->Get('friendlyname_to_anonymize').' (CSV)').' AND user_id IS NULL';
                 $sSqlUpdate = "UPDATE `$sChangeTable` SET userinfo=".CMDBSource::Quote($this->Get('anonymized_friendlyname').' (CSV)');
                 $bFinish = $this->executeQueryByLot($sSqlSearch, $sSqlUpdate, $iTimeLimit);
	           }

              if($bFinish) {
                $this->DBDelete();
                $oScopeQuery = "SELECT BatchAnonymization WHERE id_to_anonymize = :id_to_anonymize ";
                $oSet = new DBObjectSet(DBSearch::FromOQL($oScopeQuery, ['id_to_anonymize'=>$this->Get('id_to_anonymize')]));
					      if ($oSet->Count() === 0){
					          //end of anonymization mark person as anonymized
					        $oPerson = MetaModel::GetObject('Person', $this->Get('id_to_anonymize'), true,true);
                  $oPerson->Set('anonymized', true); // Mark the Person as anonymized
                  $oPerson->DBWrite();
					      }
              }
           }
        }
]]></code>
        </method>
        <method id="CleanupCaseLogsByBatch" _delta="define">
          <static>false</static>
          <access>protected</access>
          <type>Overload-DBObject</type>
          <code><![CDATA[
        protected function CleanupCaseLogsByBatch($iTimeLimit)
        {
            $aCleanupCaseLog = MetaModel::GetConfig()->GetModuleSetting('combodo-anonymizer', 'caselog_content');

            // 1) Build the expression to search (and replace)
            $sPattern = ' : %1$s (%2$d) ============';
            $sEraser = str_repeat('*', strlen($this->Get('friendlyname_to_anonymize'))); // replace the person's name by a string of stars... of the same length to preserver the case log's index
            $sSearch = sprintf($sPattern, $this->Get('friendlyname_to_anonymize'), $this->Get('id_user_to_anonymize'));

            $sSearchIdx = $this->Get('friendlyname_to_anonymize');
            $sReplaceIdx =  str_repeat('*', strlen($this->Get('friendlyname_to_anonymize')));

            if (in_array('friendlyname',$aCleanupCaseLog)){
                $sSearch1 = $this->Get('friendlyname_to_anonymize');
                $sReplace1 = $sEraser;
            } else {
               $sSearch1 = sprintf($sPattern, $this->Get('friendlyname_to_anonymize'), $this->Get('id_user_to_anonymize'));
               $sReplace1 = sprintf($sPattern, $sEraser, $this->Get('id_user_to_anonymize'));
            }
             $sStartReplace = "REPLACE(";
             $sEndReplace = ", ".CMDBSource::Quote($sSearch1).", ".CMDBSource::Quote($sReplace1).")";

            if (in_array('email',$aCleanupCaseLog)){
              $sSearch2 = $this->Get('email_to_anonymize');
              $sReplace2 = str_repeat('*', strlen($sSearch2));

               $sStartReplace = "REPLACE(".$sStartReplace;
               $sEndReplace = $sEndReplace.", ".CMDBSource::Quote($sSearch2).", ".CMDBSource::Quote($sReplace2).")";
            }

            if (in_array('name',$aCleanupCaseLog)){
               $sSearch3 = $this->Get('name_to_anonymize');
               $sReplace3 = str_repeat('*', strlen($sSearch3));

               $sStartReplace = "REPLACE(".$sStartReplace;
               $sEndReplace = $sEndReplace.", ".CMDBSource::Quote($sSearch3).", ".CMDBSource::Quote($sReplace3).")";
            }

            $bFinish = false;
            // 2) Find all classes containing case logs
            foreach(MetaModel::GetClasses() as $sClass)
            {
              foreach(MetaModel::ListAttributeDefs($sClass) as $sAttCode => $oAttDef)
              {
                $sTable = MetaModel::DBGetTable($sClass);
                if ((MetaModel::GetAttributeOrigin($sClass, $sAttCode) == $sClass) && $oAttDef instanceof AttributeCaseLog)
                {
                  $aSQLColumns = $oAttDef->GetSQLColumns();
                  $sColumn1 = array_keys($aSQLColumns)[0]; // We assume that the first column is the text
                  $sColumnIdx = array_keys($aSQLColumns)[1]; // We assume that the second column is the index

                  $sSqlSearch ="SELECT  id FROM `$sTable` WHERE `$sColumn1` LIKE ".CMDBSource::Quote('%'.$sSearch.'%');
                  $sSqlUpdate ="UPDATE `$sTable` SET `$sColumn1` = ".$sStartReplace."`$sColumn1`".$sEndReplace.",".
                                                                                " `$sColumnIdx` = REPLACE(`$sColumnIdx`, ".CMDBSource::Quote($sSearchIdx).", ".CMDBSource::Quote($sReplaceIdx).") ";
                  $bFinish = $this->executeQueryByLot($sSqlSearch,$sSqlUpdate, $iTimeLimit);
                  if (!$bFinish){
                  	//end of time
                  	return;
                  }
                }
              }
            }
             if($bFinish) {
                $this->DBDelete();
               $oScopeQuery = "SELECT BatchAnonymization WHERE id_to_anonymize = :id_to_anonymize ";
               $oSet = new DBObjectSet(DBSearch::FromOQL($oScopeQuery, ['id_to_anonymize'=>$this->Get('id_to_anonymize')]));
					      if ($oSet->Count() === 0){
					          //end of anonymization mark person as anonymized
					        $oPerson = MetaModel::GetObject('Person', $this->Get('id_to_anonymize'), true,true);
                  $oPerson->Set('anonymized', true); // Mark the Person as anonymized
                  $oPerson->DBWrite();
					      }
            }
        }
]]></code>
        </method>
        <method id="CleanupOnMentionByBatch" _delta="define">
          <static>false</static>
          <access>protected</access>
          <type>Overload-DBObject</type>
          <code><![CDATA[
        protected function CleanupOnMentionByBatch($iTimeLimit)
        {
            $sCleanupOnmention = MetaModel::GetConfig()->GetModuleSetting('combodo-anonymizer','onmention');
            $bFinish = true;
            if($sCleanupOnmention == 'trigger-only') {
	            $oScopeQuery = "SELECT TriggerOnObjectMention";
	            $oSet = new DBObjectSet(DBSearch::FromOQL($oScopeQuery, ['id_to_anonymize'=>$this->Get('id_to_anonymize')]));
	            while ($oTrigger = $oSet->Fetch()){
	               if ($bFinish) {
	                   $bFinish = $this->CleanupOnMentionInAClass($iTimeLimit, $oTrigger->Get('target_class'));
	                 }
                }
            } elseif ($sCleanupOnmention == 'all') {
               foreach(MetaModel::GetClasses() as $sClass) {
                 if ($bFinish) {
                   $bFinish = $this->CleanupOnMentionInAClass($iTimeLimit, $sClass);
                 }
              }
            }
            if($bFinish) {
              $this->DBDelete();
                 $oScopeQuery = "SELECT BatchAnonymization WHERE id_to_anonymize = :id_to_anonymize ";
                 $oSet = new DBObjectSet(DBSearch::FromOQL($oScopeQuery, ['id_to_anonymize'=>$this->Get('id_to_anonymize')]));
                  if ($oSet->Count() === 0){
                      //end of anonymization mark person as anonymized
                    $oPerson = MetaModel::GetObject('Person', $this->Get('id_to_anonymize'), true,true);
                    $oPerson->Set('anonymized', true); // Mark the Person as anonymized
                    $oPerson->DBWrite();
                  }
            }
        }

]]></code>
        </method>
        <method id="CleanupOnMentionInAClass" _delta="define">
          <static>false</static>
          <access>protected</access>
          <type>Overload-DBObject</type>
          <code><![CDATA[
        protected function CleanupOnMentionInAClass($iTimeLimit, $sParentClass)
        {
              $bFinish = false;
              $aMentionsAllowedClasses = MetaModel::GetConfig()->Get('mentions.allowed_classes');
              if (sizeof($aMentionsAllowedClasses) == 0 ){
                return true;
              }
               $aCleanupCaseLog = MetaModel::GetConfig()->GetModuleSetting('combodo-anonymizer', 'caselog_content');

               $sSearch1 = $this->Get('friendlyname_to_anonymize');
               $sReplaceInCaseLog1 =  str_repeat('*', strlen($this->Get('friendlyname_to_anonymize')));
               $sReplaceInText1 =  str_repeat('*', strlen($this->Get('friendlyname_to_anonymize')));
               $sStartReplace = "REPLACE(";
               $sEndReplaceInCaseLog = ", ".CMDBSource::Quote($sSearch1).", ".CMDBSource::Quote($sReplaceInCaseLog1).")";
               $sEndReplaceInText = ", ".CMDBSource::Quote($sSearch1).", ".CMDBSource::Quote($sReplaceInText1).")";

                if (in_array('email',$aCleanupCaseLog)){
                  $sSearch2 = $this->Get('email_to_anonymize');
                  $sReplaceInCaseLog2 = str_repeat('*', strlen($sSearch2));
                  $sReplaceInText2 =  'anonymous.contact'.$this->Get('id_to_anonymize').'@anony.mized';;

                   $sStartReplace = "REPLACE(".$sStartReplace;
                   $sEndReplaceInCaseLog = $sEndReplaceInCaseLog.", ".CMDBSource::Quote($sSearch2).", ".CMDBSource::Quote($sReplaceInCaseLog2).")";
                   $sEndReplaceInText = $sEndReplaceInText.", ".CMDBSource::Quote($sSearch2).", ".CMDBSource::Quote($sReplaceInText2).")";
                }

                if (in_array('name',$aCleanupCaseLog)){
                   $sSearch3 = $this->Get('name_to_anonymize');
                   $sReplaceInCaseLog3 = str_repeat('*', strlen($sSearch3));
                   $sReplaceInText3 = 'Contact '.$this->Get('id_to_anonymize');

                   $sStartReplace = "REPLACE(".$sStartReplace;
                   $sEndReplaceInCaseLog = $sEndReplaceInCaseLog.", ".CMDBSource::Quote($sSearch3).", ".CMDBSource::Quote($sReplaceInCaseLog3).")";
                   $sEndReplaceInText = $sEndReplaceInText.", ".CMDBSource::Quote($sSearch3).", ".CMDBSource::Quote($sReplaceInText3).")";
                }
               $aClasses = array_merge([$sParentClass], MetaModel::GetSubclasses($sParentClass));
               $aAlreadyDone = [];
               foreach ($aClasses as $sClass)
               {
                 foreach (MetaModel::ListAttributeDefs($sClass) as $sAttCode => $oAttDef)
                {
                    $sTable = MetaModel::DBGetTable($sClass, $sAttCode);
                    if (!in_array($sTable.'->'.$sAttCode, $aAlreadyDone))
                    {
                        $aAlreadyDone[] = $sTable.'->'.$sAttCode;
                      if ((MetaModel::GetAttributeOrigin($sClass, $sAttCode) == $sClass) )
                      {
                        if ( $oAttDef instanceof AttributeCaseLog){
                            $aSQLColumns = $oAttDef->GetSQLColumns();
                            $sColumn1 = array_keys($aSQLColumns)[0]; // We assume that the first column is the text
                            //don't change number of characters
                            foreach ($aMentionsAllowedClasses as $sMentionChar => $sMentionClass) {
                               if (MetaModel::IsParentClass('User',$sMentionClass)) {
                                    $sSearch = 'class='.$sMentionClass.'&amp;id='.$this->Get('id_user_to_anonymize')."\">@";
                                } elseif (MetaModel::IsParentClass('Contact',$sMentionClass))  {
                                    $sSearch = "class=".$sMentionClass."&amp;id=".$this->Get('id_to_anonymize')."\">@";
                                }
                                $sSqlSearch = "SELECT id from `$sTable` WHERE `$sColumn1` LIKE ".CMDBSource::Quote('%'.$sSearch.'%');
                               /* function REGEXP_REPLACE available in mysql 8.0
                                $sRegexPatternToFind = $sSearch1."(.*?)</a>/i'";
                                $sReplaceableText = $sSearch1.CMDBSource::Quote($this->Get('anonymized_friendlyname'))."</a>";
                                $sSqlUpdate = "UPDATE `$sTable` SET `$sColumn1` = REGEXP_REPLACE(`$sColumn1`,'".CMDBSource::Quote($sRegexPatternToFind)."','".CMDBSource::Quote($sReplaceableText)."')";
                               */
                                $sSqlUpdate ="UPDATE `$sTable` SET `$sColumn1` = ".$sStartReplace."`$sColumn1`".$sEndReplaceInCaseLog;
                                $bFinish = $this->executeQueryByLot($sSqlSearch,$sSqlUpdate, $iTimeLimit);
                                if (!$bFinish){
                                     //end of time
                                    return $bFinish;
                                }
                            }
                      }/* TO ADD when onmention is on AttributeText
                       elseif ( $oAttDef instanceof AttributeText){
                            $aSQLColumns = $oAttDef->GetSQLColumns();
                            $sColumn1 = array_keys($aSQLColumns)[0]; // We assume that the first column is the text

                            foreach ($aMentionsAllowedClasses as $sMentionChar => $sMentionClass) {
                               if (MetaModel::IsParentClass('User',$sMentionClass)) {
                                    $sSearch = 'class='.$sMentionClass.'&amp;id='.$this->Get('id_user_to_anonymize')."\">@";
                                } elseif (MetaModel::IsParentClass('Contact',$sMentionClass))  {
                                    $sSearch = "class=".$sMentionClass."&amp;id=".$this->Get('id_to_anonymize')."\">@";
                                }
                                $sSqlSearch = "SELECT id from `$sTable` WHERE `$sColumn1` LIKE ".CMDBSource::Quote('%'.$sSearch.'%');
                                $sSqlUpdate ="UPDATE `$sTable` SET `$sColumn1` = ".$sStartReplace."`$sColumn1`".$sEndReplaceInText;
                                $bFinish = $this->executeQueryByLot($sSqlSearch,$sSqlUpdate, $iTimeLimit);
                                if (!$bFinish){
                                     //end of time
                                    return $bFinish;
                                }
                            }
                      }*/
                    }
                 }
             }
           }
           return $bFinish;
        }

]]></code>
        </method>
        <method id="CleanupEmailByBatch" _delta="define">
          <static>false</static>
          <access>protected</access>
          <type>Overload-DBObject</type>
          <code><![CDATA[
        protected function CleanupEmailByBatch( $iTimeLimit)
        {
           $sEmailAnonymized = 'anonymous.contact'.$this->Get('id_to_anonymize').'@anony.mized';
           $aCleanupEmail = (array) MetaModel::GetConfig()->GetModuleSetting('combodo-anonymizer','notification_content');
           if(sizeof($aCleanupEmail) == 0){
                $bFinish = true;
           } else {
             $sStartReplace = "";
             $sEndReplace = "";

             if (in_array('friendlyname',$aCleanupEmail)){
                 $sSearch1 = $this->Get('friendlyname_to_anonymize');
                 $sReplace1 = $this->Get('anonymized_friendlyname');

                 $sStartReplace = "REPLACE(";
                 $sEndReplace = ", ".CMDBSource::Quote($sSearch1).", ".CMDBSource::Quote($sReplace1).")";
              }

              if (in_array('email',$aCleanupEmail)){
                $sSearch2 = $this->Get('email_to_anonymize');
                $sReplace2 = 'anonymous.contact'.$this->Get('id_to_anonymize').'@anony.mized';

                 $sStartReplace = "REPLACE(".$sStartReplace;
                 $sEndReplace = $sEndReplace.", ".CMDBSource::Quote($sSearch2).", ".CMDBSource::Quote($sReplace2).")";
              }

              if (in_array('name',$aCleanupEmail)){
                 $sSearch3 = $this->Get('name_to_anonymize');
                 $sReplace3 = "Contact ".$this->Get('id_to_anonymize');

                 $sStartReplace = "REPLACE(".$sStartReplace;
                 $sEndReplace = $sEndReplace.", ".CMDBSource::Quote($sSearch3).", ".CMDBSource::Quote($sReplace3).")";
              }

             // Now change email adress
            $sNotificationTable = MetaModel::DBGetTable('EventNotificationEmail');

            $sSqlSearch = "SELECT id from `$sNotificationTable` WHERE `from` like '".$this->Get('email_to_anonymize')."'";
            $sSqlUpdate = "UPDATE `$sNotificationTable` SET  `from` = REPLACE(`from`, '".$this->Get('email_to_anonymize')."', '".$sEmailAnonymized."'),".
                                                                                 "  `subject` = ".$sStartReplace."`subject`".$sEndReplace.",".
                                                                                 "  `body` = ".$sStartReplace."`body`".$sEndReplace." ";
            $bFinish = $this->executeQueryByLot($sSqlSearch,$sSqlUpdate, $iTimeLimit);

             if ( $bFinish ) {
                $sSqlSearch = "SELECT id from `$sNotificationTable` WHERE `to` like '%".$this->Get('email_to_anonymize')."%'";
                $sSqlUpdate = "UPDATE `$sNotificationTable` SET  `to` = REPLACE(`to`, '".$this->Get('email_to_anonymize')."', '".$sEmailAnonymized."'),".
                                                                                 "  `subject` = ".$sStartReplace."`subject`".$sEndReplace.",".
                                                                                 "  `body` = ".$sStartReplace."`body`".$sEndReplace."";
                 $bFinish = $this->executeQueryByLot($sSqlSearch, $sSqlUpdate, $iTimeLimit);
            }

             if ( $bFinish ) {
                 $sSqlSearch = "SELECT id from `$sNotificationTable` WHERE `cc` like '%".$this->Get('email_to_anonymize')."%'";
                  $sSqlUpdate = "UPDATE `$sNotificationTable` SET  `cc` = REPLACE(`cc`, '".$this->Get('email_to_anonymize')."', '".$sEmailAnonymized."'),".
                                                                                 "  `subject` = ".$sStartReplace."`subject`".$sEndReplace.",".
                                                                                 "  `body` = ".$sStartReplace."`body`".$sEndReplace." ";
                 $bFinish = $this->executeQueryByLot($sSqlSearch, $sSqlUpdate, $iTimeLimit);
            }

             if ( $bFinish ) {
                 $sSqlSearch = "SELECT id from `$sNotificationTable` WHERE `bcc` like '%".$this->Get('email_to_anonymize')."%'";
                  $sSqlUpdate = "UPDATE `$sNotificationTable` SET  `bcc` = REPLACE(`bcc`, '".$this->Get('email_to_anonymize')."', '".$sEmailAnonymized."'),".
                                                                                 "  `subject` = ".$sStartReplace."`subject`".$sEndReplace.",".
                                                                                 "  `body` = ".$sStartReplace."`body`".$sEndReplace." ";
                 $bFinish = $this->executeQueryByLot($sSqlSearch, $sSqlUpdate, $iTimeLimit);
            }
	       }

          if($bFinish) {
               $this->DBDelete();
               $oScopeQuery = "SELECT BatchAnonymization WHERE id_to_anonymize = :id_to_anonymize ";
               $oSet = new DBObjectSet(DBSearch::FromOQL($oScopeQuery, ['id_to_anonymize'=>$this->Get('id_to_anonymize')]));
					      if ($oSet->Count() === 0){
					          //end of anonymization mark person as anonymized
					        $oPerson = MetaModel::GetObject('Person', $this->Get('id_to_anonymize'), true,true);
                  $oPerson->Set('anonymized', true); // Mark the Person as anonymized
                  $oPerson->DBWrite();
					      }
          }
        }
]]></code>
        </method>
      </methods>
      <presentation>
        <list>
          <items>
            <item id="class_to_anonymize">
              <rank>10</rank>
            </item>
            <item id="id_to_anonymize">
              <rank>20</rank>
            </item>
            <item id="id_user_to_anonymize">
              <rank>30</rank>
            </item>
            <item id="friendlyname_to_anonymize">
              <rank>40</rank>
            </item>
            <item id="email_to_anonymize">
              <rank>50</rank>
            </item>
            <item id="function">
              <rank>60</rank>
            </item>
          </items>
        </list>
      </presentation>
    </class>
    <class id="Person">
      <properties>
        <uniqueness_rules>
          <rule id="name" _delta="must_exist">
            <filter _delta="redefine" ><![CDATA[anonymized = 0]]></filter>
          </rule>
        </uniqueness_rules>
      </properties>
      <fields>
        <field id="anonymized" xsi:type="AttributeBoolean" _delta="define">
          <sql>anonymized</sql>
          <is_null_allowed>false</is_null_allowed>
          <default_value>0</default_value>
        </field>
      </fields>
      <methods>
        <method id="Anonymize" _delta="define">
          <static>false</static>
          <access>public</access>
          <type>Overload-DBObject</type>
          <code><![CDATA[
        public function Anonymize()
        {
          $sPersonFriendlyName = $this->GetName();
          $sEmail = $this->Get('email');
          $sNameToAnonymize = $this->Get('name');

          // Cleanup all non mandatory values
          foreach(MetaModel::ListAttributeDefs(get_class($this)) as $sAttCode => $oAttDef)
          {
            if (!$oAttDef->IsWritable()) continue;

            if ($oAttDef->IsScalar())
            {
              if (!$oAttDef->IsNullAllowed())
              {
                // Try to put the default value is a suitable one exists
                $value = $oAttDef->GetDefaultValue($this);
                if (!$oAttDef->IsNull($value))
                {
                  $this->Set($sAttCode, $value);
                }
              }
              else
              {
                $this->Set($sAttCode, null);
              }
            }
          }

          // Put some more fancy values
          $this->SetAnonymousValues();

          //TODO when min iTop Version > 3.0 : save person after the purge of his data
          // actually in case of error during purge, person is already anonymized and it isn't possible to restart the processus
          // in 2.7 we can't get anonymized friendlyname whitout save object
          //persons are marked as anonymized later when all the process is finish

          // Write the object
         $this->AllowWrite(true);
         $this->DBWrite();

          $this->Reload();
          $sAnonymizedFriendlyname = $this->GetName();

           //desactivate linked user
	        $oValues = ['class_to_anonymize' => get_class($this),
                        'id_to_anonymize' => $this->GetKey(),
                        'id_user_to_anonymize' => null,
                        'friendlyname_to_anonymize' => $sPersonFriendlyName,
                        'anonymized_friendlyname' => $sAnonymizedFriendlyname,
                        'name_to_anonymize' =>  $sNameToAnonymize,
                        'email_to_anonymize' => $sEmail];
          $bUserExist = false;
          $oSearch = new DBObjectSearch('User');
          $oSearch->AddCondition('contactid', $this->GetKey());
          $oSearch->AllowAllData(true);
          $oSet = new DBObjectSet($oSearch);
          $iNbUser = 0;
          while($oUser = $oSet->Fetch())
          {
	          $oUser->Set('status', 'disabled');
	          if ($iNbUser == 0) {
	              $oUser->Set('login', 'Anonymous'.$this->GetKey());
	          }  else {
	              $oUser->Set('login', 'Anonymous'.$this->GetKey().'-'.$iNbUser);
	          }
	          $oUser->AllowWrite(true);
	          $oUser->DBUpdate();

	          $bUserExist = true;
            $oValues [  'id_user_to_anonymize'] = $oUser->GetKey();

            // Purge the history for this object, otherwise previous values can be retrieved from the history
            $oValues['function'] =  'PurgeHistoryByBatch';
            $oBatchAnonymization = MetaModel::NewObject("BatchAnonymization",$oValues);
	          $oBatchAnonymization->DBInsertNoReload();

            // Cleanup all references to the Person's name as an author of a case log entry
	          $oValues['function'] =  'CleanupCaseLogsByBatch';
            $oBatchAnonymization = MetaModel::NewObject("BatchAnonymization",$oValues);
	          $oBatchAnonymization->DBInsertNoReload();

            if (version_compare(ITOP_DESIGN_LATEST_VERSION , '3.0') >= 0) {
              $oValues['function'] =  'CleanupOnMentionByBatch';
              $oBatchAnonymization = MetaModel::NewObject("BatchAnonymization",$oValues);
              $oBatchAnonymization->DBInsertNoReload();
	          }

	          if (!empty($sEmail)){
              $oValues['function'] =  'CleanupEmailByBatch';
              $oBatchAnonymization = MetaModel::NewObject("BatchAnonymization",$oValues);
              $oBatchAnonymization->DBInsertNoReload();
	          }
	          $iNbUser++;
          }

          if (!$bUserExist) {
            // Purge the history for this object, otherwise previous values can be retrieved from the history
            $oValues['function'] =  'PurgeHistoryByBatch';
	          $oBatchAnonymization = MetaModel::NewObject("BatchAnonymization",$oValues);
	          $oBatchAnonymization->DBInsertNoReload();
            if (version_compare(ITOP_DESIGN_LATEST_VERSION , '3.0') >= 0) {
                $oValues['function'] =  'PurgeOnMentionByBatch';
                $oBatchAnonymization = MetaModel::NewObject("BatchAnonymization",$oValues);
                $oBatchAnonymization->DBInsertNoReload();
	          }

	          if (!empty($sEmail)){
              $oValues['function'] =  'CleanupEmailByBatch';
              $oBatchAnonymization = MetaModel::NewObject("BatchAnonymization",$oValues);
              $oBatchAnonymization->DBInsertNoReload();
	          }
          }

        }
]]></code>
        </method>
        <method id="SetAnonymousValues" _delta="define">
          <static>false</static>
          <access>protected</access>
          <type>Overload-DBObject</type>
          <code><![CDATA[
        public function SetAnonymousValues()
        {
          // Put some more fancy values
          $this->Set('name', Dict::S('Anonymization:Person:name').' '.$this->GetKey());
          $this->Set('first_name', Dict::S('Anonymization:Person:first_name'));
          $this->Set('email', '');
          // Mark the contact as obsolete
          $this->Set('status', 'inactive');
          $this->Set('picture',null);
        }

]]></code>
        </method>
      </methods>
    </class>
  </classes>
  <menus>
  </menus>
  <user_rights>
    <groups>
      <group id="RessourceAnonymizationGroup">
        <classes>
          <class id="RessourceAnonymization"/>
          <class id="BatchAnonymization"/>
        </classes>
      </group>
      <group id="RessourcePersonGroup">
        <classes>
          <class id="Location"/>
          <class id="Organization"/>
          <class id="Contact"/>
        </classes>
      </group>
    </groups>
    <profiles>
      <profile id="52" _delta="define">
        <name>Anonymization Agent</name>
        <description>Person in charge of anonymization. Must be used in conjunction with other profiles (e.g. Configuration Manager, Service Manager,…).</description>
        <groups>
          <group id="RessourceAnonymizationGroup">
            <actions>
              <action id="action:read">allow</action>
              <action id="action:bulk read">allow</action>
              <action id="action:write">allow</action>
              <action id="action:bulk write">allow</action>
            </actions>
          </group>
          <group id="RessourcePersonGroup">
            <actions>
              <action id="action:read">allow</action>
              <action id="action:bulk read">allow</action>
            </actions>
          </group>
        </groups>
      </profile>
    </profiles>
  </user_rights>
  <dictionaries>
    <dictionary id="EN US">
      <entries>
        <entry id="Class:Person/Attribute:anonymized" _delta="define"><![CDATA[Anonymized?]]></entry>
      </entries>
    </dictionary>
    <dictionary id="FR FR">
      <entries>
        <entry id="Class:Person/Attribute:anonymized" _delta="define"><![CDATA[Anonymisé ?]]></entry>
      </entries>
    </dictionary>
  </dictionaries>
</itop_design>
